<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8">
  <title>PHPUnit マニュアル &#8211; 第4章 フィクスチャ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="canonical" href="fixtures.html">
  <link href="css/bootstrap.min.css" rel="stylesheet">
  <link href="css/highlight.css" rel="stylesheet">
  <link href="css/style.css" rel="stylesheet">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700%7CSource+Code+Pro:400,700' rel='stylesheet' type='text/css'>
  <!--[if lt IE 9]><script src="js/html5shiv.min.js"></script><![endif]-->
 </head>
 <body>
  
  <div class="container-fluid">
   <div class="row">
    <div style='padding: 2.0em'>
     <div class="row">
      <div class="col-md-1 pull-left prev-nav"><a accesskey="p" href="textui.html">戻る</a></div>
      <div class="col-md-1 pull-right next-nav"><a accesskey="n" href="organizing-tests.html">次へ</a></div>
     </div>
<div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="fixtures"></a>第4章 フィクスチャ</h1></div></div></div><p>
    <a id="idp326080" class="indexterm"></a>

    テストを記述する際にいちばん時間を食うのは、テストを開始するための事前設定と
    テスト終了後の後始末の処理を書くことです。この事前設定は、テストの
    <span class="emphasis"><em>フィクスチャ</em></span> と呼ばれます。
  </p><p>
    <a class="xref" href="writing-tests-for-phpunit.html#writing-tests-for-phpunit.examples.StackTest.php" title="例 2.1: PHPUnit での配列操作のテスト">例 2.1</a>
    では、フィクスチャは
    <code class="literal">$stack</code> という変数に格納された配列だけでした。
    しかし、たいていの場合はフィクスチャはこれより複雑なものとなり、
    それを準備するにはかなりの量のコードが必要です。本来のテストの内容が、
    フィクスチャを設定するためのコードの中に埋もれてしまうことになります。
    この問題は、複数のテストで同じようなフィクスチャを設定する場合により顕著になります。
    テストフレームワークの助けがなければ、
    個々のテストのなかで同じような準備コードを繰り返し書くはめになってしまいます。
  </p><p>
    <a id="idp518208" class="indexterm"></a>
    <a id="idp518752" class="indexterm"></a>
    <a id="idp519328" class="indexterm"></a>

    PHPUnit は、準備用のコードの共有をサポートしています。
    各テストメソッドが実行される前に、<code class="literal">setUp()</code>
    という名前のテンプレートメソッドが実行されます。<code class="literal">setUp()</code>
    は、テスト対象のオブジェクトを生成するような処理に使用します。
    テストメソッドの実行が終了すると、それが成功したか否かにかかわらず、
    <code class="literal">tearDown()</code> という名前の別のテンプレートメソッドが実行されます。
    <code class="literal">tearDown()</code> では、テスト対象のオブジェクトの後始末などを行います。
  </p><p>
    <a class="xref" href="writing-tests-for-phpunit.html#writing-tests-for-phpunit.examples.StackTest2.php" title="例 2.2: @depends アノテーションを使った依存性の表現">例 2.2</a>
    producer-consumer の関係を使って複数のテストでフィクスチャを共有しました。
    これは常に要求されるというものではありませんし、常に可能だとも限りません。
    <a class="xref" href="fixtures.html#fixtures.examples.StackTest.php" title="例 4.1: setUp() を使用して stack フィクスチャを作成する">例 4.1</a> では、
    フィクスチャを再利用するのではなくコードで作成する方式で
    <code class="literal">StackTest</code> にテストを書く方法をごらんいただきましょう。
    まずインスタンス変数 <code class="literal">$stack</code> を宣言し、
    メソッドローカル変数のかわりにこれを使うことにします。
    そして、<code class="literal">array</code> の作成を
    <code class="literal">setUp()</code> メソッドで行います。
    最後に、冗長なコードをテストメソッドから削除し、
    アサーションメソッド <code class="literal">assertEquals()</code>
    ではメソッド変数 <code class="literal">$stack</code> のかわりに
    新たに導入したインスタンス変数 <code class="literal">$this-&gt;stack</code>
    を使うようにします。
  </p><div class="example"><a id="fixtures.examples.StackTest.php"></a><p class="title"><strong>例 4.1: setUp() を使用して stack フィクスチャを作成する</strong></p><div class="example-contents"><pre class="programlisting">&lt;?php
class StackTest extends PHPUnit_Framework_TestCase
{
    protected $stack;

    protected function setUp()
    {
        $this-&gt;stack = array();
    }

    public function testEmpty()
    {
        $this-&gt;assertTrue(empty($this-&gt;stack));
    }

    public function testPush()
    {
        array_push($this-&gt;stack, 'foo');
        $this-&gt;assertEquals('foo', $this-&gt;stack[count($this-&gt;stack)-1]);
        $this-&gt;assertFalse(empty($this-&gt;stack));
    }

    public function testPop()
    {
        array_push($this-&gt;stack, 'foo');
        $this-&gt;assertEquals('foo', array_pop($this-&gt;stack));
        $this-&gt;assertTrue(empty($this-&gt;stack));
    }
}
?&gt;</pre></div></div><br class="example-break"></br><p>
    <a id="idp529792" class="indexterm"></a>
    <a id="idp530368" class="indexterm"></a>
    <a id="idp530944" class="indexterm"></a>
    <a id="idp531520" class="indexterm"></a>
    <a id="idp256176" class="indexterm"></a>

    テンプレートメソッド <code class="literal">setUp()</code> および <code class="literal">tearDown()</code>
    は、テストケースクラスのテストメソッドごとに (そして最初にインスタンスを作成したときに)
    一度ずつ実行されます。
  </p><p>
    <a id="idp258224" class="indexterm"></a>
    <a id="idp258800" class="indexterm"></a>
    <a id="idp259376" class="indexterm"></a>
    <a id="idp259952" class="indexterm"></a>
    <a id="idp260528" class="indexterm"></a>
    <a id="idp261104" class="indexterm"></a>
    <a id="idp261680" class="indexterm"></a>
    <a id="idp262256" class="indexterm"></a>

    さらに、テンプレートメソッド <code class="literal">setUpBeforeClass()</code> および
    <code class="literal">tearDownAfterClass()</code> が存在します。
    これらはそれぞれ、テストケースクラスの最初のテストメソッドの実行前と
    テストケースクラスの最後のテストの実行後にコールされます。
  </p><p>
    <a id="idp264352" class="indexterm"></a>

    以下の例は、テストケースクラスで使用できるすべてのテンプレートメソッドを示すものです。
  </p><div class="example"><a id="fixtures.examples.TemplateMethodsTest.php"></a><p class="title"><strong>例 4.2: 利用可能なすべてのテンプレートメソッド</strong></p><div class="example-contents"><pre class="programlisting">&lt;?php
class TemplateMethodsTest extends PHPUnit_Framework_TestCase
{
    public static function setUpBeforeClass()
    {
        fwrite(STDOUT, __METHOD__ . "\n");
    }

    protected function setUp()
    {
        fwrite(STDOUT, __METHOD__ . "\n");
    }

    protected function assertPreConditions()
    {
        fwrite(STDOUT, __METHOD__ . "\n");
    }

    public function testOne()
    {
        fwrite(STDOUT, __METHOD__ . "\n");
        $this-&gt;assertTrue(TRUE);
    }

    public function testTwo()
    {
        fwrite(STDOUT, __METHOD__ . "\n");
        $this-&gt;assertTrue(FALSE);
    }

    protected function assertPostConditions()
    {
        fwrite(STDOUT, __METHOD__ . "\n");
    }

    protected function tearDown()
    {
        fwrite(STDOUT, __METHOD__ . "\n");
    }

    public static function tearDownAfterClass()
    {
        fwrite(STDOUT, __METHOD__ . "\n");
    }

    protected function onNotSuccessfulTest(Exception $e)
    {
        fwrite(STDOUT, __METHOD__ . "\n");
        throw $e;
    }
}
?&gt;</pre><pre class="screen"><strong class="userinput"><code>phpunit TemplateMethodsTest</code></strong>
PHPUnit 5.3.0 by Sebastian Bergmann and contributors.

TemplateMethodsTest::setUpBeforeClass
TemplateMethodsTest::setUp
TemplateMethodsTest::assertPreConditions
TemplateMethodsTest::testOne
TemplateMethodsTest::assertPostConditions
TemplateMethodsTest::tearDown
.TemplateMethodsTest::setUp
TemplateMethodsTest::assertPreConditions
TemplateMethodsTest::testTwo
TemplateMethodsTest::tearDown
TemplateMethodsTest::onNotSuccessfulTest
FTemplateMethodsTest::tearDownAfterClass


Time: 0 seconds, Memory: 5.25Mb

There was 1 failure:

1) TemplateMethodsTest::testTwo
Failed asserting that &lt;boolean:false&gt; is true.
/home/sb/TemplateMethodsTest.php:30

FAILURES!
Tests: 2, Assertions: 2, Failures: 1.</pre></div></div><br class="example-break"></br><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="fixtures.more-setup-than-teardown"></a>tearDown() よりも setUp()</h2></div></div></div><p>
      <code class="literal">setUp()</code> と <code class="literal">tearDown()</code>
      は理屈上では対称的になるはずですが、実際にはそうではありません。実際には、
      <code class="literal">tearDown()</code> を実装する必要があるのは <code class="literal">setUp()</code>
      で外部リソース (ファイルやソケットなど) を割り当てた場合のみです。もし
      <code class="literal">setUp()</code> で単に PHP オブジェクトを作成しただけの場合は、
      一般には <code class="literal">tearDown()</code> は必要ありません。しかし、もし
      <code class="literal">setUp()</code> で大量のオブジェクトを作成した場合には、
      それらの後始末をするために <code class="literal">tearDown()</code> で変数を
      <code class="literal">unset()</code> したくなることもあるでしょう。
      テストケースオブジェクト自体のガベージコレクションにはあまり意味がありません。
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="fixtures.variations"></a>バリエーション</h2></div></div></div><p>
      ふたつのテストがあって、それぞれの setup がほんの少しだけ違う場合にはどうなるでしょう?
      このような場合は、二種類の可能性が考えられます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          もし <code class="literal">setUp()</code> の違いがごくわずかなものなら、
          その違う部分を <code class="literal">setUp()</code>
          からテストメソッドのほうに移動させます。
        </p></li><li class="listitem"><p>
          <code class="literal">setUp()</code> の違いが大きければ、
          テストケースクラスを別に分ける必要があります。それぞれのクラスには、
          setup の違いを表す名前をつけます。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="fixtures.sharing-fixture"></a>フィクスチャの共有</h2></div></div></div><p>
      複数のテストの間でフィクスチャを共有する利点は、ほとんどありません。
      しかし、設計上の問題などでどうしても
      フィクスチャを共有しなければならないこともあるでしょう。
    </p><p>
      複数のテスト間で共有する意味のあるフィクスチャの例として意味のあるものといえば、
      データベースとの接続でしょう。テストのたびに新しいデータベース接続を毎回作成するのではなく、
      最初にログインした状態を再利用するということです。こうすることで、
      テストの実行時間を短縮できます。
    </p><p>
      <a id="idp449008" class="indexterm"></a>
      <a id="idp449584" class="indexterm"></a>

      <a class="xref" href="fixtures.html#fixtures.sharing-fixture.examples.DatabaseTest.php" title="例 4.3: テストスイートの複数テスト間でのフィクスチャの共有">例 4.3</a>
      では、テンプレートメソッド <code class="literal">setUpBeforeClass()</code> および
      <code class="literal">tearDownAfterClass()</code> を用いて、
      テストケースクラス内の最初のテストを実行する前にデータベースに接続し、
      最後のテストが終わってから接続を切断するようにしています。
    </p><div class="example"><a id="fixtures.sharing-fixture.examples.DatabaseTest.php"></a><p class="title"><strong>例 4.3: テストスイートの複数テスト間でのフィクスチャの共有</strong></p><div class="example-contents"><pre class="programlisting">&lt;?php
class DatabaseTest extends PHPUnit_Framework_TestCase
{
    protected static $dbh;

    public static function setUpBeforeClass()
    {
        self::$dbh = new PDO('sqlite::memory:');
    }

    public static function tearDownAfterClass()
    {
        self::$dbh = NULL;
    }
}
?&gt;</pre></div></div><br class="example-break"></br><p>
      このようにフィクスチャを共有することがテストの価値を下げてしまうということを、
      まだうまく伝え切れていないかもしれません。問題なのは、
      各オブジェクトが疎結合になっていないという設計なのです。
      複数が連携しているようなテストを作って設計上の問題から目をそらしてしまうのではなく、
      きちんと設計しなおした上で、スタブ (<a class="xref" href="test-doubles.html" title="第9章 テストダブル">第 9 章</a> を参照ください)
      を使用するテストを書くことをお勧めします。
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="fixtures.global-state"></a>グローバルな状態</h2></div></div></div><p>
      <a class="ulink" href="http://googletesting.blogspot.com/2008/05/tott-using-dependancy-injection-to.html" target="_top">singleton
      を使用するコードをテストするのはたいへんです</a>。
      同様に、グローバル変数を使うコードのテストもまたたいへんです。
      一般に、テスト対象のコードはグローバル変数と密接に関連しており、
      グローバル変数の内容を制御することはできません。
      さらに別の問題もあって、あるテストの中でグローバル変数を変更してしまうと
      別のテストがうまく動かなくなる可能性があります。
    </p><p>
      PHP では、グローバル変数は次のような動きをします。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>グローバル変数 <code class="literal">$foo = 'bar';</code> は、<code class="literal">$GLOBALS['foo'] = 'bar';</code> として格納される。</p></li><li class="listitem"><p><code class="literal">$GLOBALS</code> は<span class="emphasis"><em>スーパーグローバル</em></span>変数と呼ばれる。</p></li><li class="listitem"><p>スーパーグローバル変数は組み込みの変数で、すべてのスコープで常に利用できる。</p></li><li class="listitem"><p>関数やメソッドのスコープでグローバル変数 <code class="literal">$foo</code> にアクセスするには、直接 <code class="literal">$GLOBALS['foo']</code> にアクセスするか、あるいは <code class="literal">global $foo;</code> を用いて (グローバル変数を参照する) ローカル変数を作成する。</p></li></ul></div><p>
      グローバル変数のほかに、クラスの静的属性もグローバル状態となります。
    </p><p>
      <a id="idp465296" class="indexterm"></a>
      <a id="idp465872" class="indexterm"></a>

      デフォルトでは、PHPUnit がテストを実行する際には、
      グローバル変数やスーパーグローバル変数 (<code class="literal">$GLOBALS</code>,
      <code class="literal">$_ENV</code>, <code class="literal">$_POST</code>,
      <code class="literal">$_GET</code>, <code class="literal">$_COOKIE</code>,
      <code class="literal">$_SERVER</code>, <code class="literal">$_FILES</code>,
      <code class="literal">$_REQUEST</code>) への変更が他のテストへの影響を及ぼさないようにします。
      オプションで、この分離をクラスの静的属性まで拡張することもできます。
    </p><div class="alert alert-info"><h3 class="title">注記</h3><p>
        グローバル変数やクラスの静的属性のバックアップ・リストアには
        <code class="literal">serialize()</code> および
        <code class="literal">unserialize()</code> を使用しています。
      </p><p>
        PHP 組み込みの一部のクラス、たとえば <code class="literal">PDO</code>
        のオブジェクトはシリアライズできないため、そのようなオブジェクトが
        <code class="literal">$GLOBALS</code> 配列に格納されている場合はバックアップ操作が失敗します。
      </p></div><p>
      <a id="idp474208" class="indexterm"></a>
      <a id="idp474912" class="indexterm"></a>

      <a class="xref" href="appendixes.annotations.html#appendixes.annotations.backupGlobals" title="@backupGlobals">「@backupGlobals」</a> で説明している
      <code class="literal">@backupGlobals</code> アノテーションを使用すると、
      グローバル変数のバックアップ・リストア操作を制御することができます。
      あるいは、グローバル変数のブラックリストを指定して、
      その変数だけはバックアップ・リストアの対象から除外することもできます。
      </p><pre class="programlisting">class MyTest extends PHPUnit_Framework_TestCase
{
    protected $backupGlobalsBlacklist = array('globalVariable');

    // ...
}</pre><p>
    </p><div class="alert alert-info"><h3 class="title">注記</h3><p>
        <code class="literal">$backupGlobalsBlacklist</code>
        プロパティをたとえば <code class="literal">setUp()</code>
        メソッド内で設定しても効果が及びません。
      </p></div><p>
      <a id="idp479728" class="indexterm"></a>
      <a id="idp480432" class="indexterm"></a>

      <a class="xref" href="appendixes.annotations.html#appendixes.annotations.backupStaticAttributes" title="@backupStaticAttributes">「@backupStaticAttributes」</a>
      で説明する <code class="literal">@backupStaticAttributes</code> アノテーションを使うと、
      宣言されたクラス内のすべての static プロパティの値をバックアップしてからテストを始め、
      テストが終わった後でそれらの値を復元することができます。
    </p><p>
      テストが始まる際に、宣言されたすべてのクラスについて処理を行います。テストクラス自身だけではありません。
      処理するのは、クラスの static プロパティだけです。関数の内部の static 変数は対象外です。
    </p><div class="alert alert-info"><h3 class="title">注記</h3><p>
        <code class="literal">@backupStaticAttributes</code> の操作は、テストメソッドの前に実行されます。
        ただし、有効になっている場合だけです。
        先に実行されたテストメソッドの中で static プロパティの値が変更されており、かつそのメソッドでは
        <code class="literal">@backupStaticAttributes</code> が有効になっていなかった場合、
        バックアップ (そしてリストア) されるのは、先に実行されたメソッドで変更後の値になります。
        もともと宣言されていたデフォルト値ではありません。
        PHP は、static 変数が宣言された当時のデフォルト値を、どこにも記録していないのです。
      </p><p>
        これは、テストの内部で新しく読み込んだ (宣言した) クラスの static プロパティについても同様です。
        この場合も、もともと宣言されていたデフォルト値を、テストの後に復元することはできません。デフォルト値が残っていないからです。
        テスト内で設定された値が、それ以降のテストに持ち越されます。
      </p><p>
        ユニットテストでは、テスト対象の static プロパティの値は、<code class="literal">setUp()</code>
        で明示的にリセットしておくことを推奨します
        (そして、<code class="literal">tearDown()</code> でもリセットしておけば、それ以降のテストに影響を及ぼすこともなくなります)。
      </p></div><p>
      static 属性のブラックリストを渡せば、保存と復元の対象からそれらを除外することもできます。
      ブラックリストは、このように指定します。

      </p><pre class="programlisting">
class MyTest extends PHPUnit_Framework_TestCase
{
    protected $backupStaticAttributesBlacklist = array(
      'className' =&gt; array('attributeName')
    );

    // ...
}
</pre><p>
    </p><div class="alert alert-info"><h3 class="title">注記</h3><p>
        <code class="literal">$backupStaticAttributesBlacklist</code>
        プロパティをたとえば <code class="literal">setUp()</code>
        メソッド内で設定しても効果が及びません。
      </p></div></div></div>
     <div class="row">
      <div class="col-md-1 pull-left prev-nav"><a accesskey="p" href="textui.html">戻る</a></div>
      <div class="col-md-1 pull-right next-nav"><a accesskey="n" href="organizing-tests.html">次へ</a></div>
     </div>



    </div>
   </div>
   <hr/>
   <footer>
    <p><a href="appendixes.copyright.html">Copyright</a> &copy; 2005-2016 <a href="http://sebastian-bergmann.de/">Sebastian Bergmann</a>.</p>
   </footer>
  </div>
  <script src="js/jquery.js"></script>
  <script src="js/bootstrap.min.js"></script>
  <script src="js/highlight.pack.js"></script>
  <script type="text/javascript">
  $(document).ready(function() { $('pre.programlisting').each(function(i, e) {hljs.highlightBlock(e)}); });
  </script>
 </body>
</html>
