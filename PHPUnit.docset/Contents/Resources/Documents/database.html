<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8">
  <title>PHPUnit マニュアル &#8211; 第8章 データベースのテスト</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="canonical" href="database.html">
  <link href="css/bootstrap.min.css" rel="stylesheet">
  <link href="css/highlight.css" rel="stylesheet">
  <link href="css/style.css" rel="stylesheet">
  <!--[if lt IE 9]><script src="js/html5shiv.min.js"></script><![endif]-->
 </head>
 <body>
  
  <div class="container-fluid">
   <div class="row">
    <div class="col-md-4 col-lg-3">
     <div class="well well-sm sidebar-nav">
<dl class="toc nav hidden-print"><dt><span class="chapter"><a href="installation.html">1. PHPUnit のインストール</a></span></dt><dd><dl><dt><span class="section"><a href="installation.html#installation.requirements">要件</a></span></dt><dt><span class="section"><a href="installation.html#installation.phar">PHP Archive (PHAR)</a></span></dt><dd><dl><dt><span class="section"><a href="installation.html#installation.phar.windows">Windows</a></span></dt><dt><span class="section"><a href="installation.html#installation.phar.verification">PHPUnit の PHAR リリースの検証</a></span></dt></dl></dd><dt><span class="section"><a href="installation.html#installation.composer">Composer</a></span></dt><dt><span class="section"><a href="installation.html#installation.optional-packages">オプションのパッケージ</a></span></dt></dl></dd><dt><span class="chapter"><a href="writing-tests-for-phpunit.html">2. PHPUnit 用のテストの書き方</a></span></dt><dd><dl><dt><span class="section"><a href="writing-tests-for-phpunit.html#writing-tests-for-phpunit.test-dependencies">テストの依存性</a></span></dt><dt><span class="section"><a href="writing-tests-for-phpunit.html#writing-tests-for-phpunit.data-providers">データプロバイダ</a></span></dt><dt><span class="section"><a href="writing-tests-for-phpunit.html#writing-tests-for-phpunit.exceptions">例外のテスト</a></span></dt><dt><span class="section"><a href="writing-tests-for-phpunit.html#writing-tests-for-phpunit.errors">PHP のエラーのテスト</a></span></dt><dt><span class="section"><a href="writing-tests-for-phpunit.html#writing-tests-for-phpunit.output">出力内容のテスト</a></span></dt><dt><span class="section"><a href="writing-tests-for-phpunit.html#writing-tests-for-phpunit.error-output">エラー出力</a></span></dt><dd><dl><dt><span class="section"><a href="writing-tests-for-phpunit.html#writing-tests-for-phpunit.error-output.edge-cases">エッジケース</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="textui.html">3. コマンドラインのテストランナー</a></span></dt><dd><dl><dt><span class="section"><a href="textui.html#textui.clioptions">コマンドラインオプション</a></span></dt></dl></dd><dt><span class="chapter"><a href="fixtures.html">4. フィクスチャ</a></span></dt><dd><dl><dt><span class="section"><a href="fixtures.html#fixtures.more-setup-than-teardown">tearDown() よりも setUp()</a></span></dt><dt><span class="section"><a href="fixtures.html#fixtures.variations">バリエーション</a></span></dt><dt><span class="section"><a href="fixtures.html#fixtures.sharing-fixture">フィクスチャの共有</a></span></dt><dt><span class="section"><a href="fixtures.html#fixtures.global-state">グローバルな状態</a></span></dt></dl></dd><dt><span class="chapter"><a href="organizing-tests.html">5. テストの構成</a></span></dt><dd><dl><dt><span class="section"><a href="organizing-tests.html#organizing-tests.filesystem">ファイルシステムを用いたテストスイートの構成</a></span></dt><dt><span class="section"><a href="organizing-tests.html#organizing-tests.xml-configuration">XML 設定ファイルを用いたテストスイートの構成</a></span></dt></dl></dd><dt><span class="chapter"><a href="risky-tests.html">6. リスクを伴うテスト</a></span></dt><dd><dl><dt><span class="section"><a href="risky-tests.html#risky-tests.useless-tests">無意味なテスト</a></span></dt><dt><span class="section"><a href="risky-tests.html#risky-tests.unintentionally-covered-code">意図せぬうちにカバーされているコード</a></span></dt><dt><span class="section"><a href="risky-tests.html#risky-tests.output-during-test-execution">テストの実行時の出力</a></span></dt><dt><span class="section"><a href="risky-tests.html#risky-tests.test-execution-timeout">テストの実行時のタイムアウト</a></span></dt><dt><span class="section"><a href="risky-tests.html#risky-tests.global-state-manipulation">グローバルな状態の変更</a></span></dt></dl></dd><dt><span class="chapter"><a href="incomplete-and-skipped-tests.html">7. 不完全なテスト・テストの省略</a></span></dt><dd><dl><dt><span class="section"><a href="incomplete-and-skipped-tests.html#incomplete-and-skipped-tests.incomplete-tests">不完全なテスト</a></span></dt><dt><span class="section"><a href="incomplete-and-skipped-tests.html#incomplete-and-skipped-tests.skipping-tests">テストの省略</a></span></dt><dt><span class="section"><a href="incomplete-and-skipped-tests.html#incomplete-and-skipped-tests.skipping-tests-using-requires">@requires によるテストのスキップ</a></span></dt></dl></dd><dt><span class="chapter"><a href="database.html" class="active">8. データベースのテスト</a></span></dt><dd><dl><dt><span class="section"><a href="database.html#database.supported-vendors-for-database-testing">データベースのテストに対応しているベンダー</a></span></dt><dt><span class="section"><a href="database.html#database.difficulties-in-database-testing">データベースのテストの難しさ</a></span></dt><dt><span class="section"><a href="database.html#database.the-four-stages-of-a-database-test">データベーステストの四段階</a></span></dt><dd><dl><dt><span class="section"><a href="database.html#database.clean-up-database">1. データベースのクリーンアップ</a></span></dt><dt><span class="section"><a href="database.html#database.set-up-fixture">2. フィクスチャの準備</a></span></dt><dt><span class="section"><a href="database.html#database.run-test-verify-outcome-and-teardown">3–5. テストの実行、結果の検証、そして後始末</a></span></dt></dl></dd><dt><span class="section"><a href="database.html#database.configuration-of-a-phpunit-database-testcase">PHPUnit のデータベーステストケースの設定</a></span></dt><dd><dl><dt><span class="section"><a href="database.html#database.implementing-getconnection">getConnection() の実装</a></span></dt><dt><span class="section"><a href="database.html#database.implementing-getdataset">getDataSet() の実装</a></span></dt><dt><span class="section"><a href="database.html#database.what-about-the-database-schema-ddl">データベーススキーマ (DDL) とは?</a></span></dt><dt><span class="section"><a href="database.html#database.tip-use-your-own-abstract-database-testcase">ヒント: 自前でのデータベーステストケースの抽象化</a></span></dt></dl></dd><dt><span class="section"><a href="database.html#database.understanding-datasets-and-datatables">データセットとデータテーブルについて知る</a></span></dt><dd><dl><dt><span class="section"><a href="database.html#database.available-implementations">利用できる実装</a></span></dt><dt><span class="section"><a href="database.html#database.beware-of-foreign-keys">外部キーには注意</a></span></dt><dt><span class="section"><a href="database.html#database.implementing-your-own-datasetsdatatables">自作のデータセットやデータテーブルの実装</a></span></dt></dl></dd><dt><span class="section"><a href="database.html#database.the-connection-api">接続 API</a></span></dt><dt><span class="section"><a href="database.html#database.database-assertions-api">データベースアサーション API</a></span></dt><dd><dl><dt><span class="section"><a href="database.html#database.asserting-the-row-count-of-a-table">テーブルの行数のアサーション</a></span></dt><dt><span class="section"><a href="database.html#database.asserting-the-state-of-a-table">テーブルの状態のアサーション</a></span></dt><dt><span class="section"><a href="database.html#database.asserting-the-result-of-a-query">クエリの結果のアサーション</a></span></dt><dt><span class="section"><a href="database.html#database.asserting-the-state-of-multiple-tables">複数のテーブルの状態のアサーション</a></span></dt></dl></dd><dt><span class="section"><a href="database.html#database.frequently-asked-questions">よくある質問</a></span></dt><dd><dl><dt><span class="section"><a href="database.html#database.will-phpunit-re-create-the-database-schema-for-each-test">PHPUnit は、テストごとにデータベーススキーマを作り直すの?</a></span></dt><dt><span class="section"><a href="database.html#database.am-i-required-to-use-pdo-in-my-application-for-the-database-extension-to-work">PDO を使ったアプリケーションじゃないと Database Extension を使えないの?</a></span></dt><dt><span class="section"><a href="database.html#database.what-can-i-do-when-i-get-a-too-much-connections-error"><span class="quote">「<span class="quote">Too much Connections</span>」</span> というエラーが出たらどうすればいい?</a></span></dt><dt><span class="section"><a href="database.html#database.how-to-handle-null-with-flat-xml-csv-datasets">フラット XML や CSV のデータセットで NULL を扱う方法は?</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="test-doubles.html">9. テストダブル</a></span></dt><dd><dl><dt><span class="section"><a href="test-doubles.html#test-doubles.stubs">スタブ</a></span></dt><dt><span class="section"><a href="test-doubles.html#test-doubles.mock-objects">モックオブジェクト</a></span></dt><dt><span class="section"><a href="test-doubles.html#test-doubles.prophecy">Prophecy</a></span></dt><dt><span class="section"><a href="test-doubles.html#test-doubles.mocking-traits-and-abstract-classes">トレイトと抽象クラスのモック</a></span></dt><dt><span class="section"><a href="test-doubles.html#test-doubles.stubbing-and-mocking-web-services">ウェブサービスのスタブおよびモック</a></span></dt><dt><span class="section"><a href="test-doubles.html#test-doubles.mocking-the-filesystem">ファイルシステムのモック</a></span></dt></dl></dd><dt><span class="chapter"><a href="testing-practices.html">10. テストの進め方</a></span></dt><dd><dl><dt><span class="section"><a href="testing-practices.html#testing-practices.during-development">開発中のテスト</a></span></dt><dt><span class="section"><a href="testing-practices.html#testing-practices.during-debugging">デバッグ中のテスト</a></span></dt></dl></dd><dt><span class="chapter"><a href="code-coverage-analysis.html">11. コードカバレッジ解析</a></span></dt><dd><dl><dt><span class="section"><a href="code-coverage-analysis.html#code-coverage-analysis.metrics">コードカバレッジの指標</a></span></dt><dt><span class="section"><a href="code-coverage-analysis.html#code-coverage-analysis.whitelisting-files">ファイルのホワイトリスト</a></span></dt><dt><span class="section"><a href="code-coverage-analysis.html#code-coverage-analysis.ignoring-code-blocks">コードブロックの無視</a></span></dt><dt><span class="section"><a href="code-coverage-analysis.html#code-coverage-analysis.specifying-covered-methods">カバーするメソッドの指定</a></span></dt><dt><span class="section"><a href="code-coverage-analysis.html#code-coverage-analysis.edge-cases">エッジケース</a></span></dt></dl></dd><dt><span class="chapter"><a href="other-uses-for-tests.html">12. テストのその他の使用法</a></span></dt><dd><dl><dt><span class="section"><a href="other-uses-for-tests.html#testing-practices.agile-documentation">アジャイルな文書作成</a></span></dt><dt><span class="section"><a href="other-uses-for-tests.html#testing-practices.cross-team-tests">複数チームでのテスト</a></span></dt></dl></dd><dt><span class="chapter"><a href="logging.html">13. ログ出力</a></span></dt><dd><dl><dt><span class="section"><a href="logging.html#logging.xml">テスト結果 (XML)</a></span></dt><dt><span class="section"><a href="logging.html#logging.codecoverage.xml">コードカバレッジ (XML)</a></span></dt><dt><span class="section"><a href="logging.html#logging.codecoverage.text">コードカバレッジ (テキスト)</a></span></dt></dl></dd><dt><span class="chapter"><a href="extending-phpunit.html">14. PHPUnit の拡張</a></span></dt><dd><dl><dt><span class="section"><a href="extending-phpunit.html#extending-phpunit.PHPUnit_Framework_TestCase">PHPUnit\Framework\TestCase のサブクラスの作成</a></span></dt><dt><span class="section"><a href="extending-phpunit.html#extending-phpunit.custom-assertions">カスタムアサーションの作成</a></span></dt><dt><span class="section"><a href="extending-phpunit.html#extending-phpunit.PHPUnit_Framework_TestListener">PHPUnit\Framework\TestListener の実装</a></span></dt><dt><span class="section"><a href="extending-phpunit.html#extending-phpunit.PHPUnit_Extensions_TestDecorator">PHPUnit_Extensions_TestDecorator のサブクラスの作成</a></span></dt><dt><span class="section"><a href="extending-phpunit.html#extending-phpunit.PHPUnit_Framework_Test">PHPUnit_Framework_Test の実装</a></span></dt></dl></dd><dt><span class="appendix"><a href="appendixes.assertions.html">A. アサーション</a></span></dt><dd><dl><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.static-vs-non-static-usage-of-assertion-methods">アサーションメソッドはstaticで使うべきか、それとも非staticで使うべきか</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertArrayHasKey">assertArrayHasKey()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertClassHasAttribute">assertClassHasAttribute()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertArraySubset">assertArraySubset()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertClassHasStaticAttribute">assertClassHasStaticAttribute()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertContains">assertContains()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertContainsOnly">assertContainsOnly()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertContainsOnlyInstancesOf">assertContainsOnlyInstancesOf()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertCount">assertCount()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertDirectoryExists">assertDirectoryExists()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertDirectoryIsReadable">assertDirectoryIsReadable()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertDirectoryIsWritable">assertDirectoryIsWritable()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertEmpty">assertEmpty()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertEqualXMLStructure">assertEqualXMLStructure()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertEquals">assertEquals()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertFalse">assertFalse()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertFileEquals">assertFileEquals()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertFileExists">assertFileExists()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertFileIsReadable">assertFileIsReadable()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertFileIsWritable">assertFileIsWritable()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertGreaterThan">assertGreaterThan()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertGreaterThanOrEqual">assertGreaterThanOrEqual()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertInfinite">assertInfinite()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertInstanceOf">assertInstanceOf()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertInternalType">assertInternalType()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertIsReadable">assertIsReadable()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertIsWritable">assertIsWritable()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertJsonFileEqualsJsonFile">assertJsonFileEqualsJsonFile()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertJsonStringEqualsJsonFile">assertJsonStringEqualsJsonFile()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertJsonStringEqualsJsonString">assertJsonStringEqualsJsonString()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertLessThan">assertLessThan()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertLessThanOrEqual">assertLessThanOrEqual()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertNan">assertNan()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertNull">assertNull()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertObjectHasAttribute">assertObjectHasAttribute()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertRegExp">assertRegExp()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertStringMatchesFormat">assertStringMatchesFormat()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertStringMatchesFormatFile">assertStringMatchesFormatFile()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertSame">assertSame()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertStringEndsWith">assertStringEndsWith()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertStringEqualsFile">assertStringEqualsFile()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertStringStartsWith">assertStringStartsWith()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertThat">assertThat()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertTrue">assertTrue()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertXmlFileEqualsXmlFile">assertXmlFileEqualsXmlFile()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertXmlStringEqualsXmlFile">assertXmlStringEqualsXmlFile()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertXmlStringEqualsXmlString">assertXmlStringEqualsXmlString()</a></span></dt></dl></dd><dt><span class="appendix"><a href="appendixes.annotations.html">B. アノテーション</a></span></dt><dd><dl><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.author">@author</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.after">@after</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.afterClass">@afterClass</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.backupGlobals">@backupGlobals</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.backupStaticAttributes">@backupStaticAttributes</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.before">@before</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.beforeClass">@beforeClass</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.codeCoverageIgnore">@codeCoverageIgnore*</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.covers">@covers</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.coversDefaultClass">@coversDefaultClass</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.coversNothing">@coversNothing</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.dataProvider">@dataProvider</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.depends">@depends</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.expectedException">@expectedException</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.expectedExceptionCode">@expectedExceptionCode</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.expectedExceptionMessage">@expectedExceptionMessage</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.expectedExceptionMessageRegExp">@expectedExceptionMessageRegExp</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.group">@group</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.large">@large</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.medium">@medium</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.preserveGlobalState">@preserveGlobalState</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.requires">@requires</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.runTestsInSeparateProcesses">@runTestsInSeparateProcesses</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.runInSeparateProcess">@runInSeparateProcess</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.small">@small</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.test">@test</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.testdox">@testdox</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.ticket">@ticket</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.uses">@uses</a></span></dt></dl></dd><dt><span class="appendix"><a href="appendixes.configuration.html">C. XML 設定ファイル</a></span></dt><dd><dl><dt><span class="section"><a href="appendixes.configuration.html#appendixes.configuration.phpunit">PHPUnit</a></span></dt><dt><span class="section"><a href="appendixes.configuration.html#appendixes.configuration.testsuites">テストスイート</a></span></dt><dt><span class="section"><a href="appendixes.configuration.html#appendixes.configuration.groups">グループ</a></span></dt><dt><span class="section"><a href="appendixes.configuration.html#appendixes.configuration.whitelisting-files">コードカバレッジ対象のファイルのホワイトリスト</a></span></dt><dt><span class="section"><a href="appendixes.configuration.html#appendixes.configuration.logging">ログ出力</a></span></dt><dt><span class="section"><a href="appendixes.configuration.html#appendixes.configuration.test-listeners">テストリスナー</a></span></dt><dt><span class="section"><a href="appendixes.configuration.html#appendixes.configuration.php-ini-constants-variables">PHP INI 項目や定数、グローバル変数の設定</a></span></dt></dl></dd><dt><span class="appendix"><a href="appendixes.index.html">D. 目次</a></span></dt><dd><dl><dt><span class="index"><a href="appendixes.index.html#appendixes.index.index"></a></span></dt></dl></dd><dt><span class="appendix"><a href="appendixes.bibliography.html">E. 参考文献</a></span></dt><dt><span class="appendix"><a href="appendixes.copyright.html">F. 著作権</a></span></dt></dl>
     </div>
    </div>
    <div class="col-md-8 col-lg-9">
     <div class="row">
      <div class="col-md-1 pull-left prev-nav"><a accesskey="p" href="incomplete-and-skipped-tests.html">戻る</a></div>
      <div class="col-md-1 pull-right next-nav"><a accesskey="n" href="test-doubles.html">次へ</a></div>
     </div>
<div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="database"></a>第8章 データベースのテスト</h1></div></div></div><p>
    初級者・中級者向けのユニットテストのサンプルは、
    どんな言語を対象としたものであっても、
    テストしやすいようなロジックに対してシンプルなテストをしているものばかりです。
    データベースを扱う一般的なアプリケーションを考えると、これはまったく現実離れしています。
    たとえば WordPress や TYPO3、あるいは Symfony で Doctrine や Propel などを使い始めるとすぐに、
    PHPUnit でのテストがやりづらいことを実感するはずです。
    データベースとこれらのライブラリが密結合になっているからです。
  </p><div class="alert alert-info"><h3 class="title">注記</h3><p>
      PHP の <code class="literal">pdo</code> 拡張モジュール、そしてデータベースごとの拡張モジュール
      (<code class="literal">pdo_mysql</code> など) がインストールされていることを確認しておきましょう。
      これらがインストールされていないと、以下のサンプルは動きません。
    </p></div><p>
    きっと日々の業務やプロジェクトでも身に覚えがあることでしょう。
    自分の持つ PHPUnit に関する知識を駆使して作業を進めようとしたのに、
    こんな問題のせいで行き詰ってしまうことが。
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
        テストしたいメソッドがかなり大きめの JOIN 操作を実行し、
        データを使って重要な結果を算出している。
      </p></li><li class="listitem"><p>
        ひとつのビジネスロジックの中で SELECT、INSERT、UPDATE そして DELETE
        を組み合わせて実行している。
      </p></li><li class="listitem"><p>
        ふたつ以上の (おそらくもっと多い) テーブルから初期データを準備しないと
        そのメソッドのテストができない。
      </p></li></ol></div><p>
    DBUnit 拡張を使うと、テスト用のデータベースのセットアップを単純化でき、
    データベース操作後の内容の検証もすることができます。
  </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="database.supported-vendors-for-database-testing"></a>データベースのテストに対応しているベンダー</h2></div></div></div><p>
      DBUnit が現在サポートしているのは、MySQL および
      PostgreSQL、Oracle、SQLite です。
      <a class="ulink" href="http://framework.zend.com" target="_top">Zend Framework</a> や
      <a class="ulink" href="http://www.doctrine-project.org" target="_top">Doctrine 2</a>
      を使うと、IBM DB2 や Microsoft SQL Server のような他のデータベースにもアクセスできます。
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="database.difficulties-in-database-testing"></a>データベースのテストの難しさ</h2></div></div></div><p>
      ウェブ上にあるユニットテストのサンプルの中にデータベースを扱うものが全く見当たらない理由はなぜか。
      それは、データベースを扱うテストは準備するのも保守するのもたいへんだからです。
      データベースを使うテストをするには、このようなことに気をつける必要があります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          データベースのスキーマやテーブル
        </p></li><li class="listitem"><p>
          テーブルへの、テストで必要となるレコードの追加
        </p></li><li class="listitem"><p>
          テスト実行後のデータベースの状態の検証
        </p></li><li class="listitem"><p>
          テスト実行ごとのデータベースの後始末
        </p></li></ul></div><p>
      PDO や MySQLi あるいは OCI8 といったデータベース API はどれも使いにくい上に、
      こういった処理を自分で書こうとすると長ったらしくなってしまって面倒です。
    </p><p>
      テストコードはできる限り簡潔に、そして明確に書かねばなりません。その理由は次のとおりです。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          製品コードにちょっと手を加えるたびに大量のテストコードを変更する羽目になるのは困る。
        </p></li><li class="listitem"><p>
          数ヵ月後に改めて読み直したときにも
          読みやすく理解しやすいテストコードであってほしい。
        </p></li></ul></div><p>
      さらに知っておく必要があることは、
      データベースは基本的に、自分のコードへのグローバルな入力変数であるということです。
      テストスイート内にあるふたつのテストを同じデータベースに対して実行すると、
      おそらくデータを複数回再利用することになります。あるテストが失敗すると
      それ以降のテストの結果にも影響を及ぼしやすく、テストを進めるのが非常に難しくなります。
      先ほど箇条書きでまとめた中の「後始末」こそが、この
      <span class="quote">「<span class="quote">データベースがグローバルな入力になる</span>」</span>
      問題を解決するために重要です。
    </p><p>
      DbUnit を使うと、
      データベースのテストにおけるこれらの問題をシンプルにする助けになります。
    </p><p>
      PHPUnit では助けようにもどうにもならないことが、
      データベースのテストはデータベースを使わないものに比べてとても遅くなるという事実です。
      テストの実行時間がどれくらいになるかはデータベースとのやりとりの量に依存しますが、
      各テストで使うデータの量を少なめにしておいて
      可能な限りはデータベースを使わないテストで済ませるようにすれば、
      巨大なテストスイートであっても 1 分未満で実行させるのは容易です。
    </p><p>
      <a class="ulink" href="http://www.doctrine-project.org" target="_top">Doctrine 2 プロジェクト</a> がよい例です。
      このプロジェクトのテストスイートには現時点で約 1000 件のテストが含まれています。
      そのほぼ半数がデータベースを扱うテストですが、
      標準的なデスクトップコンピューター上の MySQL
      を使ってテストスイートを実行しても 15 秒程度でテストが完了します。
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="database.the-four-stages-of-a-database-test"></a>データベーステストの四段階</h2></div></div></div><p>
      Gerard Meszaros は、著書 xUnit Test Patterns でユニットテストを次の四段階に分類しています。
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          フィクスチャのセットアップ (Setup)
        </p></li><li class="listitem"><p>
          テストしたいシステムの実行 (Exercise)
        </p></li><li class="listitem"><p>
          結果の検証 (Verify)
        </p></li><li class="listitem"><p>
          後始末 (Teardown)
        </p></li></ol></div><div class="blockquote"><blockquote class="blockquote"><p>
        <span class="strong"><strong>フィクスチャとは?</strong></span>
      </p><p>
        フィクスチャとは、アプリケーションやデータベースの初期状態のことです。
        テストを実行する前に用意します。
      </p></blockquote></div><p>
      データベースをテストするには、少なくとも setup と teardown
      のときにはテーブルに接続してフィクスチャのクリーンアップや書き込みをしなければなりません。
      しかし、データベース拡張には、
      データベーステストの四段階を次のようなワークフローに振り向ける十分な理由があります。
      このフローは、個々のテストに対して実行します。
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="database.clean-up-database"></a>1. データベースのクリーンアップ</h3></div></div></div><p>
        データベースを扱う最初のテストというのはいつでも存在します。
        実際のところ、そのときテーブルにデータが存在するのかどうかはわかりません。
        PHPUnit は指定した全テーブルに対して TRUNCATE を実行し、
        テーブルの中身を空にします。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="database.set-up-fixture"></a>2. フィクスチャの準備</h3></div></div></div><p>
        その後、PHPUnit はフィクスチャの各行を順次処理し、対応するテーブルに書き込みます。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="database.run-test-verify-outcome-and-teardown"></a>3–5. テストの実行、結果の検証、そして後始末</h3></div></div></div><p>
        データベースをリセットして初期状態を読み込んだら、
        実際のテストを PHPUnit が実行します。
        テストコードのこの部分は Database Extension の存在を知っている必要はなく、
        コードに対してなんでもお好みのテストをすることができます。
      </p><p>
        テストの中で <code class="literal">assertDataSetsEqual()</code>
        という特殊なアサーションを使って検証しているかもしれません。
        しかし、この機能は完全なオプションです。
        この機能は <span class="quote">「<span class="quote">データベースアサーション</span>」</span> で説明します。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="database.configuration-of-a-phpunit-database-testcase"></a>PHPUnit のデータベーステストケースの設定</h2></div></div></div><p>
      通常、PHPUnit を使うテストケースでは
      <code class="literal">PHPUnit\Framework\TestCase</code>
      クラスを継承してこのようにします。
    </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;

class MyTest extends TestCase
{
    public function testCalculate()
    {
        $this-&gt;assertEquals(2, 1 + 1);
    }
}
?&gt;</pre><p>
      テストコードで Database Extension を使う場合は少しだけ複雑になり、
      別の抽象テストケースを継承しなければなりません。そして、二つの抽象メソッド
      <code class="literal">getConnection()</code> と
      <code class="literal">getDataSet()</code> を実装します。
    </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class MyGuestbookTest extends TestCase
{
    use TestCaseTrait;

    /**
     * @return PHPUnit_Extensions_Database_DB_IDatabaseConnection
     */
    public function getConnection()
    {
        $pdo = new PDO('sqlite::memory:');
        return $this-&gt;createDefaultDBConnection($pdo, ':memory:');
    }

    /**
     * @return PHPUnit_Extensions_Database_DataSet_IDataSet
     */
    public function getDataSet()
    {
        return $this-&gt;createFlatXMLDataSet(dirname(__FILE__).'/_files/guestbook-seed.xml');
    }
}
?&gt;</pre><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="database.implementing-getconnection"></a>getConnection() の実装</h3></div></div></div><p>
        クリーンアップとフィクスチャの読み込みの機能を動かすには、
        PHPUnit Database Extension からデータベース接続にアクセスできなければなりません。
        データベース接続の抽象化には PDO ライブラリを使います。
        重要なのは、PHPUnit のデータベース拡張を使うためだけに
        わざわざアプリケーションを PDO ベースにする必要はないということです。
        この接続を使うのは、単にクリーンアップとフィクスチャの準備のためだけです。
      </p><p>
        先ほどの例では、インメモリの SQLite 接続を作って
        <code class="literal">createDefaultDBConnection</code> メソッドに渡しました。
        このメソッドは PDO のインスタンスをラップしたもので、二番目のパラメータ
        (データベース名) に非常にシンプルなデータベース接続の抽象化レイヤーを渡します。このパラメータの型は
        <code class="literal">PHPUnit_Extensions_Database_DB_IDatabaseConnection</code> です。
      </p><p>
        <span class="quote">「<span class="quote">データベース接続の使い方</span>」</span>で、このインターフェイスの API
        と、その活用法について説明します。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="database.implementing-getdataset"></a>getDataSet() の実装</h3></div></div></div><p>
        <code class="literal">getDataSet()</code> メソッドで定義するのは、
        個々のテストを実行する前のデータベースの初期状態がどうあるべきかということです。
        データベースの状態の抽象化は DataSet と DataTable
        という概念を使って行い、これらをそれぞれ
        <code class="literal">PHPUnit_Extensions_Database_DataSet_IDataSet</code> および
        <code class="literal">PHPUnit_Extensions_Database_DataSet_IDataTable</code>
        というインターフェイスで表します。次の節でこれらの概念を詳しく説明し、
        これをデータベースのテストに使うと何がうれしいのかについても示します。
      </p><p>
        実装するために最低限知っておくべきことは、
        <code class="literal">getDataSet()</code> メソッドがコールされるのが
        <code class="literal">setUp()</code> の中で一度だけであり、
        ここでフィクスチャのデータセットを取得してデータベースに挿入するということです。
        先ほどの例では、ファクトリメソッド
        <code class="literal">createFlatXMLDataSet($filename)</code>
        を使って XML 形式のデータセットを表しました。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="database.what-about-the-database-schema-ddl"></a>データベーススキーマ (DDL) とは?</h3></div></div></div><p>
        PHPUnit は、テストの実行前にデータベーススキーマ
        (すべてのテーブル、トリガー、シーケンス、ビューを含むもの)
        ができあがっていることを想定しています。つまり開発者としては、
        テストスイートを実行する前にデータベースを正しく準備しておかねばならないということです。
      </p><p>
        データベースのテストにおけるこの事前条件を満たす方法には、次のようなものがあります。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            インメモリの SQLite ではなく永続化したデータベースを使うのなら、
            最初に一度 phpMyAdmin (MySQL の場合) などのツールでデータベースを用意しておけば、
            あとはテストを実行するたびにそれを再利用できます。
          </p></li><li class="listitem"><p>
            <a class="ulink" href="http://www.doctrine-project.org" target="_top">Doctrine 2</a> や
            <a class="ulink" href="http://www.propelorm.org/" target="_top">Propel</a>
            といったライブラリを使っている場合は、その API を使えばテストの実行前に必要なデータベーススキーマを作ることができます。
            <a class="ulink" href="textui.html" target="_top">PHPUnit のブートストラップ</a>
            機能を使うと、そのコードをテスト実行時に毎回実行させることもできます。
          </p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="database.tip-use-your-own-abstract-database-testcase"></a>ヒント: 自前でのデータベーステストケースの抽象化</h3></div></div></div><p>
        先の実装例を見ればすぐにわかるでしょうが、
        <code class="literal">getConnection()</code> メソッドはきわめて静的なものであり、
        さまざまなデータベーステストケースで再利用することができます。
        さらに、テストのパフォーマンスを良好に保ちつつデータベースのオーバーヘッドを下げるために、
        ちょっとしたリファクタリングを施して汎用的な抽象テストケースを用意しましょう。
        このようにしても、テストケースごとに異なるデータフィクスチャを指定することができます。
      </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

abstract class MyApp_Tests_DatabaseTestCase extends TestCase
{
    use TestCaseTrait;

    // PDO のインスタンス生成は、クリーンアップおよびフィクスチャ読み込みのときに一度だけ
    static private $pdo = null;

    // PHPUnit_Extensions_Database_DB_IDatabaseConnection のインスタンス生成は、テストごとに一度だけ
    private $conn = null;

    final public function getConnection()
    {
        if ($this-&gt;conn === null) {
            if (self::$pdo == null) {
                self::$pdo = new PDO('sqlite::memory:');
            }
            $this-&gt;conn = $this-&gt;createDefaultDBConnection(self::$pdo, ':memory:');
        }

        return $this-&gt;conn;
    }
}
?&gt;</pre><p>
        しかし、これはまだデータベースへの接続情報を
        PDO 接続の設定にハードコードしてしまっています。
        PHPUnit にはさらにすばらしい機能があるので、それを使ってテストケースをより汎用的にしましょう。
        <a class="ulink" href="appendixes.configuration.html#appendixes.configuration.php-ini-constants-variables" target="_top">XML 設定ファイル</a>
        を使えば、テストの実行のたびにデータベース接続を設定できます。
        まずは <span class="quote">「<span class="quote">phpunit.xml</span>」</span> というファイルをアプリケーションの tests/ ディレクトリに作り、
        中身をこのようにします。
      </p><pre class="screen">
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;phpunit&gt;
    &lt;php&gt;
        &lt;var name="DB_DSN" value="mysql:dbname=myguestbook;host=localhost" /&gt;
        &lt;var name="DB_USER" value="user" /&gt;
        &lt;var name="DB_PASSWD" value="passwd" /&gt;
        &lt;var name="DB_DBNAME" value="myguestbook" /&gt;
    &lt;/php&gt;
&lt;/phpunit&gt;
</pre><p>
        テストケースはこのように書き直せます。
      </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

abstract class Generic_Tests_DatabaseTestCase extends TestCase
{
    use TestCaseTrait;

    // PDO のインスタンス生成は、クリーンアップおよびフィクスチャ読み込みのときに一度だけ
    static private $pdo = null;

    // PHPUnit_Extensions_Database_DB_IDatabaseConnection のインスタンス生成は、テストごとに一度だけ
    private $conn = null;

    final public function getConnection()
    {
        if ($this-&gt;conn === null) {
            if (self::$pdo == null) {
                self::$pdo = new PDO( $GLOBALS['DB_DSN'], $GLOBALS['DB_USER'], $GLOBALS['DB_PASSWD'] );
            }
            $this-&gt;conn = $this-&gt;createDefaultDBConnection(self::$pdo, $GLOBALS['DB_DBNAME']);
        }

        return $this-&gt;conn;
    }
}
?&gt;</pre><p>
        データベースの設定情報を切り替えてテストスイートを実行するには、
        コマンドラインから次のようにします。
      </p><pre class="screen"><strong class="userinput"><code>user@desktop&gt; phpunit --configuration developer-a.xml MyTests/</code></strong>
<strong class="userinput"><code>user@desktop&gt; phpunit --configuration developer-b.xml MyTests/</code></strong></pre><p>
        データベースのテストを実行するときにターゲットデータベースを切り替えられるようにしておくことは、
        開発機で作業をしている場合などは特に重要です。
        複数の開発者が同じデータベース接続を使ってデータベースのテストを実行したりすると、
        レースコンディション (競合条件) によるテストの失敗が頻発するでしょう。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="database.understanding-datasets-and-datatables"></a>データセットとデータテーブルについて知る</h2></div></div></div><p>
      PHPUnit Database Extension の中心となる概念が
      データセットとデータテーブルです。まずはこの考え方を理解することが、
      PHPUnit でのデータベースのテストをマスターする近道です。
      データセットとデータテーブルは、データベースのテーブルや行、
      そしてカラムの抽象化レイヤーです。シンプルな API
      によってデータベースの内容をオブジェクト構造に隠蔽できるだけでなく、
      データベース以外のソースによる実装もできるようになっています。
    </p><p>
      この抽象化を使って、データベースの実際の中身と我々が期待する内容を比較します。
      期待する内容は XML や YAML そして CSV などのファイルでも表せますし、
      PHP の配列として表すこともできます。
      DataSet インターフェイスと DataTable インターフェイスのおかげで、
      これらの全く異なる概念のソースをリレーショナルデータベースに見立てて
      同様に扱えるようになります。
    </p><p>
      データベースのアサーションをテストの中で行う流れは、
      次のようにシンプルな三段階となります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ひとつあるいは複数のテーブルをデータベース内から指定する
          (実際のデータセット)。
        </p></li><li class="listitem"><p>
          期待するデータセットをお好みのフォーマット (YAML, XML など)
          で用意する。
        </p></li><li class="listitem"><p>
          両者がお互いに等しいことを確認する。
        </p></li></ul></div><p>
      データセットやデータテーブルの
      PHPUnit Database Extension における使い道は、
      何もアサーションだけだというわけではありません。先ほどの節で見たように、
      これらを使ってデータベースの初期状態の内容を記述することもできます。
      フィクスチャとなるデータセットを Database TestCase
      で定義すると、それをこのように使うことができます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          データセットで指定したテーブルのすべての行を削除する。
        </p></li><li class="listitem"><p>
          データテーブルのすべての行をデータベースに書き込む。
        </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="database.available-implementations"></a>利用できる実装</h3></div></div></div><p>
        これら三種類のデータセット/データテーブルが用意されています。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            ファイルベースのデータセットやデータテーブル
          </p></li><li class="listitem"><p>
            クエリベースのデータセットやデータテーブル
          </p></li><li class="listitem"><p>
            フィルタ用や合成用のデータセットやデータテーブル
          </p></li></ul></div><p>
        ファイルベースのデータセットやデータテーブルは、
        初期状態のフィクスチャを定義したり期待する状態を定義したりするときによく使います。
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="database.flat-xml-dataset"></a>フラット XML データセット</h4></div></div></div><p>
          最も一般的なデータセットは、フラット XML と呼ばれるものです。
          これは非常にシンプルな xml 形式で、ルートノード
          <code class="literal">&lt;dataset&gt;</code>
          の中のタグがデータベースのひとつの行を表します。
          テーブルと同じ名前のタグが追加する行を表し、
          その属性がカラムを表します。
          単純な掲示板アプリケーションの例は、このようになります。
        </p><pre class="screen">
&lt;?xml version="1.0" ?&gt;
&lt;dataset&gt;
    &lt;guestbook id="1" content="Hello buddy!" user="joe" created="2010-04-24 17:15:23" /&gt;
    &lt;guestbook id="2" content="I like it!" user="nancy" created="2010-04-26 12:14:20" /&gt;
&lt;/dataset&gt;
</pre><p>
          見るからに書きやすそうですね。この場合は
          <code class="literal">&lt;guestbook&gt;</code> がテーブル名で、
          2 行が追加されます。そして、四つのカラム <span class="quote">「<span class="quote">id</span>」</span>、
          <span class="quote">「<span class="quote">content</span>」</span>、<span class="quote">「<span class="quote">user</span>」</span> そして
          <span class="quote">「<span class="quote">created</span>」</span> に、それぞれ対応する値が設定されています。
        </p><p>
          しかし、この単純性による問題もあります。
        </p><p>
          たとえば、先ほどの例で空のテーブルはどうやって指定すればいいのかがよくわかりません。
          実は、何も属性を指定せずにテーブルと同じ名前のタグを追加すれば、空のテーブルを表すことができます。
          空の guestbook テーブルを表すフラット xml ファイルは、このようになります。
        </p><pre class="screen">
&lt;?xml version="1.0" ?&gt;
&lt;dataset&gt;
    &lt;guestbook /&gt;
&lt;/dataset&gt;
</pre><p>
          フラット xml データセットでの NULL 値の処理は、あまりおもしろいものではありません。
          ほとんどのデータベースでは、NULL 値と空文字列は別のものとして扱います
          (例外のひとつは Oracle です) が、これをフラット xml
          形式で表すのは困難です。NULL 値を表すには、
          行の指定のときに属性を省略します。
          この例の掲示板で、匿名の投稿を許可し、そのときには
          user カラムに NULL を指定することにしましょう。
          guestbook テーブルの状態は、このようになります。
        </p><pre class="screen">
&lt;?xml version="1.0" ?&gt;
&lt;dataset&gt;
    &lt;guestbook id="1" content="Hello buddy!" user="joe" created="2010-04-24 17:15:23" /&gt;
    &lt;guestbook id="2" content="I like it!" created="2010-04-26 12:14:20" /&gt;
&lt;/dataset&gt;
</pre><p>
          この例では、二番目のエントリが匿名の投稿を表します。
          しかし、これはカラムの認識において深刻な問題につながります。
          データセットが等しいことを確認するアサーションでは、各データセットでテーブルの持つカラムを指定しなければなりません。
          ある属性がデータテーブルのすべての行で NULL だったなら、
          Database Extension はそのカラムがテーブルに存在することをどうやって知るというのでしょう?
        </p><p>
          フラット XML データセットはここで、重大な前提を使っています。
          テーブルの最初の行で定義されている属性が、そのテーブルのカラムを定義しているものと見なすのです。
          先ほどの例では、guestbook テーブルのカラムが
          <span class="quote">「<span class="quote">id</span>」</span> と <span class="quote">「<span class="quote">content</span>」</span>、<span class="quote">「<span class="quote">user</span>」</span> そして
          <span class="quote">「<span class="quote">created</span>」</span> であると見なすということです。二番目の行には
          <span class="quote">「<span class="quote">user</span>」</span> が定義されていないので、データベースには
          NULL を挿入します。
        </p><p>
          guestbook の最初のエントリをデータセットから削除すると、guestbook テーブルのカラムは
          <span class="quote">「<span class="quote">id</span>」</span>、<span class="quote">「<span class="quote">content</span>」</span> そして
          <span class="quote">「<span class="quote">created</span>」</span> だけになってしまいます。
          <span class="quote">「<span class="quote">user</span>」</span> が指定されていないからです。
        </p><p>
          フラット XML データセットを効率的に使うには、NULL 値がからむ場合は
          各テーブルの最初の行には NULL を含まないようにします。
          それ以降の行では、属性を省略して NULL を表すことができます。
          これはあまりスマートなやり方ではありません。
          というのも、データベースのアサーションで行の順番が影響してしまうからです。
        </p><p>
          一方、テーブルのカラムの一部だけをフラット XML データセットで指定すると、
          それ以外のカラムにはデフォルト値が設定されます。
          そのため、もし省略したカラムの定義が
          <span class="quote">「<span class="quote">NOT NULL DEFAULT NULL</span>」</span>
          などの場合はエラーになります。
        </p><p>
          結論として言えるのは、フラット XML データセットを使うなら
          NULL 値が不要な場合だけにしておいたほうがよい、ということだけです。
        </p><p>
          フラット XML データセットのインスタンスを
          Database TestCase から作るには、
          <code class="literal">createFlatXmlDataSet($filename)</code> メソッドを使います。
        </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class MyTestCase extends TestCase
{
    use TestCaseTrait;

    public function getDataSet()
    {
        return $this-&gt;createFlatXmlDataSet('myFlatXmlFixture.xml');
    }
}
?&gt;</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="database.xml-dataset"></a>XML データセット</h4></div></div></div><p>
          もうひとつ別の構造の XML データセットもあります。これは多少冗長な書き方ですが、
          フラット XML データセットにおける NULL の問題は発生しません。
          ルートノード <code class="literal">&lt;dataset&gt;</code> の配下に指定できるタグは、
          <code class="literal">&lt;table&gt;</code> や
          <code class="literal">&lt;column&gt;</code>、<code class="literal">&lt;row&gt;</code>、
          <code class="literal">&lt;value&gt;</code> そして
          <code class="literal">&lt;null /&gt;</code> です。
          先に定義した Guestbook のフラット XML と同様のデータセットは、このようになります。
        </p><pre class="screen">
&lt;?xml version="1.0" ?&gt;
&lt;dataset&gt;
    &lt;table name="guestbook"&gt;
        &lt;column&gt;id&lt;/column&gt;
        &lt;column&gt;content&lt;/column&gt;
        &lt;column&gt;user&lt;/column&gt;
        &lt;column&gt;created&lt;/column&gt;
        &lt;row&gt;
            &lt;value&gt;1&lt;/value&gt;
            &lt;value&gt;Hello buddy!&lt;/value&gt;
            &lt;value&gt;joe&lt;/value&gt;
            &lt;value&gt;2010-04-24 17:15:23&lt;/value&gt;
        &lt;/row&gt;
        &lt;row&gt;
            &lt;value&gt;2&lt;/value&gt;
            &lt;value&gt;I like it!&lt;/value&gt;
            &lt;null /&gt;
            &lt;value&gt;2010-04-26 12:14:20&lt;/value&gt;
        &lt;/row&gt;
    &lt;/table&gt;
&lt;/dataset&gt;
</pre><p>
          <code class="literal">&lt;table&gt;</code> には name が必須で、
          さらにすべてのカラムの名前を定義しなければなりません。
          また、ゼロ個以上の <code class="literal">&lt;row&gt;</code>
          要素を含めることができます。<code class="literal">&lt;row&gt;</code>
          要素を定義しなければ、そのテーブルが空であることになります。
          <code class="literal">&lt;value&gt;</code> タグや
          <code class="literal">&lt;null /&gt;</code> タグは、先に指定した
          <code class="literal">column&gt;</code> 要素の順番で指定しなければなりません。
          <code class="literal">&lt;null /&gt;</code> タグは、
          見た目の通り、値が NULL であることを表します。
        </p><p>
          XML データセットのインスタンスを
          Database TestCase から作るには、
          <code class="literal">createXmlDataSet($filename)</code> メソッドを使います。
        </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class MyTestCase extends TestCase
{
    use TestCaseTrait;

    public function getDataSet()
    {
        return $this-&gt;createXMLDataSet('myXmlFixture.xml');
    }
}
?&gt;</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="database.mysql-xml-dataset"></a>MySQL XML データセット</h4></div></div></div><p>
          この新しい XML フォーマットは、
          <a class="ulink" href="http://www.mysql.com" target="_top">MySQL データベース</a> 専用です。
          PHPUnit 3.5 以降で対応します。この形式のファイルを生成するには、
          <a class="ulink" href="http://dev.mysql.com/doc/refman/5.0/en/mysqldump.html" target="_top"><code class="literal">mysqldump</code></a>
          を使います。<code class="literal">mysqldump</code> では CSV データセットも対応していますが、
          それとは違ってこの XML 形式の場合はひとつのファイルに複数のテーブルを含めることができます。
          この形式のファイルを作るには、
          <code class="literal">mysqldump</code> を次のように実行します。
        </p><pre class="screen"><strong class="userinput"><code>mysqldump --xml -t -u [username] --password=[password] [database] &gt; /path/to/file.xml</code></strong></pre><p>
          このファイルを Database TestCase で使うには、
          <code class="literal">createMySQLXMLDataSet($filename)</code> メソッドをコールします。
        </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class MyTestCase extends TestCase
{
    use TestCaseTrait;

    public function getDataSet()
    {
        return $this-&gt;createMySQLXMLDataSet('/path/to/file.xml');
    }
}
?&gt;</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="database.yaml-dataset"></a>YAML データセット</h4></div></div></div><p>
          あるいは、YAML データセットを使って、guestbook の例をこのように表すこともできます。
        </p><pre class="screen">
guestbook:
  -
    id: 1
    content: "Hello buddy!"
    user: "joe"
    created: 2010-04-24 17:15:23
  -
    id: 2
    content: "I like it!"
    user:
    created: 2010-04-26 12:14:20
</pre><p>
          これは、シンプルで便利なうえに、さらにフラット XML
          データセットが持つ NULL の問題も解決しています。
          NULL を YAML で表すには、単にカラム名の後に何も値を指定しなければよいのです。
          空文字列を指定する場合は
          <code class="literal">column1: ""</code>
          のようにします。
        </p><p>
          YAML Dataset 用のファクトリーメソッドは今のところ Database TestCase
          に存在しないので、手動でインスタンスを生成しなければなりません。
        </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;
use PHPUnit\DbUnit\DataSet\YamlDataSet;

class YamlGuestbookTest extends TestCase
{
    use TestCaseTrait;

    protected function getDataSet()
    {
        return new YamlDataSet(dirname(__FILE__)."/_files/guestbook.yml");
    }
}
?&gt;</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="database.csv-dataset"></a>CSV データセット</h4></div></div></div><p>
          さらにもうひとつのファイルベースのデータセットとして、CSV
          ファイルを使ったものもあります。データセット内の各テーブルを、
          それぞれ単一の CSV ファイルとして扱います。
          guestbook の例では、このようなファイル
          guestbook-table.csv を定義します。
        </p><pre class="screen">
id,content,user,created
1,"Hello buddy!","joe","2010-04-24 17:15:23"
2,"I like it!","nancy","2010-04-26 12:14:20"
</pre><p>
          この形式は Excel や OpenOffice で編集できるという点で非常に便利ですが、
          CSV データセットでは NULL 値を指定することができません。
          空のカラムは、データベースのデフォルトに基づいた空の値として扱われます。
        </p><p>
          CSV データセットを作るには、このようにします。
        </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;
use PHPUnit\DbUnit\DataSet\CsvDataSet;

class CsvGuestbookTest extends TestCase
{
    use TestCaseTrait;

    protected function getDataSet()
    {
        $dataSet = new CsvDataSet();
        $dataSet-&gt;addTable('guestbook', dirname(__FILE__)."/_files/guestbook.csv");
        return $dataSet;
    }
}
?&gt;</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="database.array-dataset"></a>Array データセット</h4></div></div></div><p>
          PHPUnit の Database Extension のバージョン 1.3.2 以降では、
          配列ベースのデータセットが使えます。
          guestbook の例だと、このようになります。
        </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class ArrayGuestbookTest extends TestCase
{
    use TestCaseTrait;

    protected function getDataSet()
    {
        return new MyApp_DbUnit_ArrayDataSet(
            [
                'guestbook' =&gt; [
                    [
                        'id' =&gt; 1,
                        'content' =&gt; 'Hello buddy!',
                        'user' =&gt; 'joe',
                        'created' =&gt; '2010-04-24 17:15:23'
                    ],
                    [
                        'id' =&gt; 2,
                        'content' =&gt; 'I like it!',
                        'user' =&gt; null,
                        'created' =&gt; '2010-04-26 12:14:20'
                    ],
                ],
            ]
        );
    }
}
?&gt;</pre><p>
          PHP の DataSet には、これまでのファイルベースのデータセットに比べて明らかな利点があります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              PHP の配列は <code class="literal">NULL</code> 値を扱える。
            </p></li><li class="listitem"><p>
              アサーション用に新たなファイルを用意する必要がなく、
              直接テストケース内で指定できる。
            </p></li></ul></div><p>
          このデータセットでは、フラット XML や CSV そして YAML
          データセットと同様に、最初に指定した行のキーがテーブルのカラム名を表します。
          つまり、先ほどの例だと <span class="quote">「<span class="quote">id</span>」</span>、
          <span class="quote">「<span class="quote">content</span>」</span>、<span class="quote">「<span class="quote">user</span>」</span> そして
          <span class="quote">「<span class="quote">created</span>」</span> です。
        </p><p>
          このデータセットの実装は、シンプルでわかりやすいものです。
        </p><pre class="programlisting">&lt;?php
class MyApp_DbUnit_ArrayDataSet extends PHPUnit_Extensions_Database_DataSet_AbstractDataSet
{
    /**
     * @var array
     */
    protected $tables = [];

    /**
     * @param array $data
     */
    public function __construct(array $data)
    {
        foreach ($data AS $tableName =&gt; $rows) {
            $columns = [];
            if (isset($rows[0])) {
                $columns = array_keys($rows[0]);
            }

            $metaData = new PHPUnit_Extensions_Database_DataSet_DefaultTableMetaData($tableName, $columns);
            $table = new PHPUnit_Extensions_Database_DataSet_DefaultTable($metaData);

            foreach ($rows AS $row) {
                $table-&gt;addRow($row);
            }
            $this-&gt;tables[$tableName] = $table;
        }
    }

    protected function createIterator($reverse = false)
    {
        return new PHPUnit_Extensions_Database_DataSet_DefaultTableIterator($this-&gt;tables, $reverse);
    }

    public function getTable($tableName)
    {
        if (!isset($this-&gt;tables[$tableName])) {
            throw new InvalidArgumentException("$tableName is not a table in the current database.");
        }

        return $this-&gt;tables[$tableName];
    }
}
?&gt;</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="database.query-sql-dataset"></a>Query (SQL) データセット</h4></div></div></div><p>
          データベースのアサーションでは、ファイルベースのデータセットだけでなく
          Query/SQL ベースのデータセットでデータベースの実際の中身を含むものが必要になることもあります。
          そんなときに使えるのが Query データセットです。
        </p><pre class="programlisting">&lt;?php
$ds = new PHPUnit_Extensions_Database_DataSet_QueryDataSet($this-&gt;getConnection());
$ds-&gt;addTable('guestbook');
?&gt;</pre><p>
          単にテーブル名だけを指定してテーブルを追加すると、
          次のクエリを実行してデータテーブルを定義したのと同じ意味になります。
        </p><pre class="programlisting">&lt;?php
$ds = new PHPUnit_Extensions_Database_DataSet_QueryDataSet($this-&gt;getConnection());
$ds-&gt;addTable('guestbook', 'SELECT * FROM guestbook');
?&gt;</pre><p>
          ここでテーブルに対して任意のクエリを実行して、
          取得する行や列を絞り込んだり
          <code class="literal">ORDER BY</code> 句を追加したりすることができます。
        </p><pre class="programlisting">&lt;?php
$ds = new PHPUnit_Extensions_Database_DataSet_QueryDataSet($this-&gt;getConnection());
$ds-&gt;addTable('guestbook', 'SELECT id, content FROM guestbook ORDER BY created DESC');
?&gt;</pre><p>
          データベースアサーションの節で、このデータセットを使う方法をより詳しく説明しています。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="database.database-db-dataset"></a>Database (DB) データセット</h4></div></div></div><p>
          テスト用のデータベース接続にアクセスすると、
          自動的にすべてのテーブルとその中身を含むデータセットを生成します。
          接続先のデータベースは、接続用のファクトリーメソッドの二番目のパラメータで指定します。
        </p><p>
          データベース全体の完全なデータセットを作るには
          <code class="literal">testGuestbook()</code> のようにします。
          ホワイトリスト形式で指定したテーブルだけに絞り込むには
          <code class="literal">testFilteredGuestbook()</code> メソッドのようにします。
        </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class MySqlGuestbookTest extends TestCase
{
    use TestCaseTrait;

    /**
     * @return PHPUnit_Extensions_Database_DB_IDatabaseConnection
     */
    public function getConnection()
    {
        $database = 'my_database';
        $user = 'my_user';
        $password = 'my_password';
        $pdo = new PDO('mysql:...', $user, $password);
        return $this-&gt;createDefaultDBConnection($pdo, $database);
    }

    public function testGuestbook()
    {
        $dataSet = $this-&gt;getConnection()-&gt;createDataSet();
        // ...
    }

    public function testFilteredGuestbook()
    {
        $tableNames = ['guestbook'];
        $dataSet = $this-&gt;getConnection()-&gt;createDataSet($tableNames);
        // ...
    }
}
?&gt;</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="database.replacement-dataset"></a>Replacement データセット</h4></div></div></div><p>
          これまで、フラット XML や CSV のデータセットには NULL
          の問題があると説明してきました。
          しかし、ちょっとわかりにくい回避策を使えばこれらのデータセットで
          NULL を扱うこともできます。
        </p><p>
          Replacement データセットは既存のデータセットに対するデコレータで、
          データセットの任意のカラムの値を別の値で置換することができます。
          guestbook の例で NULL 値を扱うには、このようなファイルを作ります。
        </p><pre class="screen">
&lt;?xml version="1.0" ?&gt;
&lt;dataset&gt;
    &lt;guestbook id="1" content="Hello buddy!" user="joe" created="2010-04-24 17:15:23" /&gt;
    &lt;guestbook id="2" content="I like it!" user="##NULL##" created="2010-04-26 12:14:20" /&gt;
&lt;/dataset&gt;
</pre><p>
          そして、フラット XML データセットを Replacement データセットでラップします。
        </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class ReplacementTest extends TestCase
{
    use TestCaseTrait;

    public function getDataSet()
    {
        $ds = $this-&gt;createFlatXmlDataSet('myFlatXmlFixture.xml');
        $rds = new PHPUnit_Extensions_Database_DataSet_ReplacementDataSet($ds);
        $rds-&gt;addFullReplacement('##NULL##', null);
        return $rds;
    }
}
?&gt;</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="database.dataset-filter"></a>データセットフィルタ</h4></div></div></div><p>
          巨大なフィクスチャファイルを扱うときには、
          データセットフィルタをホワイトリストあるいはブラックリストとして使って
          テーブルやカラムを絞り込んだサブデータセットを作ることができます。
          これは、DB データセットと組み合わせて
          データセットのカラムを絞り込むときに使うと非常に便利です。
        </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class DataSetFilterTest extends TestCase
{
    use TestCaseTrait;

    public function testIncludeFilteredGuestbook()
    {
        $tableNames = ['guestbook'];
        $dataSet = $this-&gt;getConnection()-&gt;createDataSet();

        $filterDataSet = new PHPUnit_Extensions_Database_DataSet_DataSetFilter($dataSet);
        $filterDataSet-&gt;addIncludeTables(['guestbook']);
        $filterDataSet-&gt;setIncludeColumnsForTable('guestbook', ['id', 'content']);
        // ..
    }

    public function testExcludeFilteredGuestbook()
    {
        $tableNames = ['guestbook'];
        $dataSet = $this-&gt;getConnection()-&gt;createDataSet();

        $filterDataSet = new PHPUnit_Extensions_Database_DataSet_DataSetFilter($dataSet);
        $filterDataSet-&gt;addExcludeTables(['foo', 'bar', 'baz']); // only keep the guestbook table!
        $filterDataSet-&gt;setExcludeColumnsForTable('guestbook', ['user', 'created']);
        // ..
    }
}
?&gt;</pre><div class="blockquote"><blockquote class="blockquote"><p>
            <span class="strong"><strong>注意</strong></span>
            ひとつのテーブルに対してカラムの exclude フィルタと
            include フィルタを同時に使うことはできません。
            さらに、テーブルのホワイトリストとブラックリストはどちらか一方しか指定できません。
          </p></blockquote></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="database.composite-dataset"></a>Composite データセット</h4></div></div></div><p>
          Composite データセットは、既存の複数のデータセットをひとつにまとめるときに有用です。
          複数のデータセットに同名のテーブルが含まれる場合は、
          指定した順で行を連結します。
          たとえば、このようなふたつのデータセットがあるものとしましょう。
          まずは <span class="emphasis"><em>fixture1.xml</em></span>。
        </p><pre class="screen">
&lt;?xml version="1.0" ?&gt;
&lt;dataset&gt;
    &lt;guestbook id="1" content="Hello buddy!" user="joe" created="2010-04-24 17:15:23" /&gt;
&lt;/dataset&gt;
</pre><p>
          そして <span class="emphasis"><em>fixture2.xml</em></span>。
        </p><pre class="screen">
&lt;?xml version="1.0" ?&gt;
&lt;dataset&gt;
    &lt;guestbook id="2" content="I like it!" user="##NULL##" created="2010-04-26 12:14:20" /&gt;
&lt;/dataset&gt;
</pre><p>
          Composite データセットを使えば、両方のフィクスチャファイルをまとめることができます。
        </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class CompositeTest extends TestCase
{
    use TestCaseTrait;

    public function getDataSet()
    {
        $ds1 = $this-&gt;createFlatXmlDataSet('fixture1.xml');
        $ds2 = $this-&gt;createFlatXmlDataSet('fixture2.xml');

        $compositeDs = new PHPUnit_Extensions_Database_DataSet_CompositeDataSet();
        $compositeDs-&gt;addDataSet($ds1);
        $compositeDs-&gt;addDataSet($ds2);

        return $compositeDs;
    }
}
?&gt;</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="database.beware-of-foreign-keys"></a>外部キーには注意</h3></div></div></div><p>
        フィクスチャを準備するとき、PHPUnit の Database Extension
        はフィクスチャ内で定義された順に行を追加していきます。
        データベースのスキーマ定義で外部キーを使っている場合は、
        外部キー制約に違反しないような順番でテーブルを指定しなければなりません。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="database.implementing-your-own-datasetsdatatables"></a>自作のデータセットやデータテーブルの実装</h3></div></div></div><p>
        データセットやデータテーブルの内部構造を理解するために、
        まずはデータセットのインターフェイスから見ていきましょう。
        自分でデータセットやデータテーブルを作るつもりのない人は、
        読み飛ばしてもかまいません。
      </p><pre class="programlisting">&lt;?php
interface PHPUnit_Extensions_Database_DataSet_IDataSet extends IteratorAggregate
{
    public function getTableNames();
    public function getTableMetaData($tableName);
    public function getTable($tableName);
    public function assertEquals(PHPUnit_Extensions_Database_DataSet_IDataSet $other);

    public function getReverseIterator();
}
?&gt;</pre><p>
        公開インターフェイスは、データベーステストケースの
        <code class="literal">assertDataSetsEqual()</code>
        アサーションで内部的に使われており、これでデータセットの内容を検証します。
        IDataSet は <code class="literal">IteratorAggregate</code>
        インターフェイスから <code class="literal">getIterator()</code>
        メソッドを継承しており、これを使ってデータセット内の全テーブルの反復処理を行います。
        リバースイテレータを使うと、PHPUnit で作ったテーブルのデータの切り詰めを、
        テーブルを作ったときと逆の順番で行えます。これで、外部キー制約に違反せずに済むようになります。
      </p><p>
        テーブルのインスタンスをデータセットに追加するには、
        実装によってさまざまな手法があります。たとえば
        <code class="literal">YamlDataSet</code> や
        <code class="literal">XmlDataSet</code> そして <code class="literal">FlatXmlDataSet</code>
        のようなファイルベースのデータセットでは、
        データセットの作成時にソースファイルを使って内部的に追加します。
      </p><p>
        テーブルは、このようなインターフェイスを使って表します。
      </p><pre class="programlisting">&lt;?php
interface PHPUnit_Extensions_Database_DataSet_ITable
{
    public function getTableMetaData();
    public function getRowCount();
    public function getValue($row, $column);
    public function getRow($row);
    public function assertEquals(PHPUnit_Extensions_Database_DataSet_ITable $other);
}
?&gt;</pre><p>
        <code class="literal">getTableMetaData()</code> メソッドは別として、
        それ以外のメソッドはまさに文字通りの働きをするものです。
        これらのメソッドはすべて、Database Extension のさまざまなアサーションで必須となります。
        その詳細は次の章で説明します。
        <code class="literal">getTableMetaData()</code> メソッドの返す値は、
        <code class="literal">PHPUnit_Extensions_Database_DataSet_ITableMetaData</code>
        インターフェイスを実装したものでなければなりません。
        このインターフェイスはテーブルの構造を表し、このような情報を保持します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            テーブル名。
          </p></li><li class="listitem"><p>
            テーブルのカラム名の配列。並び順は、結果セットに登場する順と同じ。
          </p></li><li class="listitem"><p>
            主キーカラムの配列。
          </p></li></ul></div><p>
        このインターフェイスには、ふたつの TableMetaData
        のインスタンスがお互いに等しいかを調べるアサーションも定義されています。
        これは、データセットの同一性を調べるアサーションで利用するものです。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="database.the-connection-api"></a>接続 API</h2></div></div></div><p>
      Connection インターフェイスには、三種類のおもしろいメソッドが用意されています。
      このインターフェイスは、データベーステストケースの
      <code class="literal">getConnection()</code> メソッドが返すものです。
    </p><pre class="programlisting">&lt;?php
interface PHPUnit_Extensions_Database_DB_IDatabaseConnection
{
    public function createDataSet(Array $tableNames = NULL);
    public function createQueryTable($resultName, $sql);
    public function getRowCount($tableName, $whereClause = NULL);

    // ...
}
?&gt;</pre><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          <code class="literal">createDataSet()</code> メソッドは、Database
          (DB) データセットを作ります。これは、データセットの実装の節で説明したものです。
        </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class ConnectionTest extends TestCase
{
    use TestCaseTrait;

    public function testCreateDataSet()
    {
        $tableNames = ['guestbook'];
        $dataSet = $this-&gt;getConnection()-&gt;createDataSet();
    }
}
?&gt;</pre></li><li class="listitem"><p>
          <code class="literal">createQueryTable()</code> メソッドを使うと、
          QuryTable のインスタンスを作れます。引数には、結果の名前と SQL クエリを渡します。
          これは、次の節 (データベースアサーション API)
          で説明する結果やテーブルのアサーションで有用なメソッドです。
        </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class ConnectionTest extends TestCase
{
    use TestCaseTrait;

    public function testCreateQueryTable()
    {
        $tableNames = ['guestbook'];
        $queryTable = $this-&gt;getConnection()-&gt;createQueryTable('guestbook', 'SELECT * FROM guestbook');
    }
}
?&gt;</pre></li><li class="listitem"><p>
          <code class="literal">getRowCount()</code> は、
          テーブル内の行数を手軽に取得するためのメソッドです。
          オプションで、where 句によるフィルタリングもできます。
          これを使えば、シンプルな同一性のアサーションが可能です。
        </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class ConnectionTest extends TestCase
{
    use TestCaseTrait;

    public function testGetRowCount()
    {
        $this-&gt;assertEquals(2, $this-&gt;getConnection()-&gt;getRowCount('guestbook'));
    }
}
?&gt;</pre></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="database.database-assertions-api"></a>データベースアサーション API</h2></div></div></div><p>
      テストツール用として、Database Extension ではいくつかのアサーションを提供しています。
      これらを使えば、データベースやテーブルの現在の状態
      そしてテーブルの行数を検証できます。この節では、
      これらの機能の詳細を説明します。
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="database.asserting-the-row-count-of-a-table"></a>テーブルの行数のアサーション</h3></div></div></div><p>
        テーブルの行数が特定の値であるかどうかを調べられれば便利なことがよくあります。
        これは、接続 API を使ってちょっとしたコードを書かなくとも簡単に実現できます。
        guestbook に行を追加した後で、初期登録した 2 エントリ以外にもう一行増えて
        3 行になっていることを調べるには、このようにします。
      </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class GuestbookTest extends TestCase
{
    use TestCaseTrait;

    public function testAddEntry()
    {
        $this-&gt;assertEquals(2, $this-&gt;getConnection()-&gt;getRowCount('guestbook'), "Pre-Condition");

        $guestbook = new Guestbook();
        $guestbook-&gt;addEntry("suzy", "Hello world!");

        $this-&gt;assertEquals(3, $this-&gt;getConnection()-&gt;getRowCount('guestbook'), "Inserting failed");
    }
}
?&gt;</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="database.asserting-the-state-of-a-table"></a>テーブルの状態のアサーション</h3></div></div></div><p>
        先ほどのアサーションも有用ですが、本当にチェックしたいのは、
        すべての値が正しいカラムにきちんと登録されたかどうかです。
        これは、テーブルのアサーションで実現します。
      </p><p>
        そのために、QueryTable のインスタンスを定義しました。
        テーブル名と SQL クエリからその内容を取得し、
        それをファイルベースあるいは配列ベースのデータセットと比較します。
      </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class GuestbookTest extends TestCase
{
    use TestCaseTrait;

    public function testAddEntry()
    {
        $guestbook = new Guestbook();
        $guestbook-&gt;addEntry("suzy", "Hello world!");

        $queryTable = $this-&gt;getConnection()-&gt;createQueryTable(
            'guestbook', 'SELECT * FROM guestbook'
        );
        $expectedTable = $this-&gt;createFlatXmlDataSet("expectedBook.xml")
                              -&gt;getTable("guestbook");
        $this-&gt;assertTablesEqual($expectedTable, $queryTable);
    }
}
?&gt;</pre><p>
        さて次に、このアサーションに使うフラット XML ファイル
        <span class="emphasis"><em>expectedBook.xml</em></span> を用意しましょう。
      </p><pre class="screen">
&lt;?xml version="1.0" ?&gt;
&lt;dataset&gt;
    &lt;guestbook id="1" content="Hello buddy!" user="joe" created="2010-04-24 17:15:23" /&gt;
    &lt;guestbook id="2" content="I like it!" user="nancy" created="2010-04-26 12:14:20" /&gt;
    &lt;guestbook id="3" content="Hello world!" user="suzy" created="2010-05-01 21:47:08" /&gt;
&lt;/dataset&gt;
</pre><p>
        残念ながら、このアサーションが成功するのは、ちょうど
        <span class="emphasis"><em>2010–05–01 21:47:08</em></span> に実行したときだけになります。
        日付はデータベースのテストでいつも問題になるものなので、それを回避する手段として
        <span class="quote">「<span class="quote">created</span>」</span> カラムをアサーションで無視させることができます。
      </p><p>
        調整後のフラット XML ファイル <span class="emphasis"><em>expectedBook.xml</em></span>
        はこのようになり、これでアサーションを通過させることができます。
      </p><pre class="screen">
&lt;?xml version="1.0" ?&gt;
&lt;dataset&gt;
    &lt;guestbook id="1" content="Hello buddy!" user="joe" /&gt;
    &lt;guestbook id="2" content="I like it!" user="nancy" /&gt;
    &lt;guestbook id="3" content="Hello world!" user="suzy" /&gt;
&lt;/dataset&gt;
</pre><p>
        QueryTable の呼び出しも修正しなければなりません。
      </p><pre class="programlisting">&lt;?php
$queryTable = $this-&gt;getConnection()-&gt;createQueryTable(
    'guestbook', 'SELECT id, content, user FROM guestbook'
);
?&gt;</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="database.asserting-the-result-of-a-query"></a>クエリの結果のアサーション</h3></div></div></div><p>
        複雑なクエリの結果に対するアサーションも、
        QueryTable 方式で可能です。単に結果の名前とクエリを指定して、
        それをデータセットと比較すればよいのです。
      </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class ComplexQueryTest extends TestCase
{
    use TestCaseTrait;

    public function testComplexQuery()
    {
        $queryTable = $this-&gt;getConnection()-&gt;createQueryTable(
            'myComplexQuery', 'SELECT complexQuery...'
        );
        $expectedTable = $this-&gt;createFlatXmlDataSet("complexQueryAssertion.xml")
                              -&gt;getTable("myComplexQuery");
        $this-&gt;assertTablesEqual($expectedTable, $queryTable);
    }
}
?&gt;</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="database.asserting-the-state-of-multiple-tables"></a>複数のテーブルの状態のアサーション</h3></div></div></div><p>
        もちろん、複数のテーブルの状態を一度に確かめたり
        クエリデータセットをファイルベースのデータセットと比較したりすることも可能です。
        データセットのアサーションには二通りの方法があります。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            接続の Database (DB) データセットを使い、
            それをファイルベースのデータセットと比較する。
          </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class DataSetAssertionsTest extends TestCase
{
    use TestCaseTrait;

    public function testCreateDataSetAssertion()
    {
        $dataSet = $this-&gt;getConnection()-&gt;createDataSet(['guestbook']);
        $expectedDataSet = $this-&gt;createFlatXmlDataSet('guestbook.xml');
        $this-&gt;assertDataSetsEqual($expectedDataSet, $dataSet);
    }
}
?&gt;</pre></li><li class="listitem"><p>
            データセットを自分で作ることもできます。
          </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class DataSetAssertionsTest extends TestCase
{
    use TestCaseTrait;

    public function testManualDataSetAssertion()
    {
        $dataSet = new PHPUnit_Extensions_Database_DataSet_QueryDataSet();
        $dataSet-&gt;addTable('guestbook', 'SELECT id, content, user FROM guestbook'); // additional tables
        $expectedDataSet = $this-&gt;createFlatXmlDataSet('guestbook.xml');

        $this-&gt;assertDataSetsEqual($expectedDataSet, $dataSet);
    }
}
?&gt;</pre></li></ol></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="database.frequently-asked-questions"></a>よくある質問</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="database.will-phpunit-re-create-the-database-schema-for-each-test"></a>PHPUnit は、テストごとにデータベーススキーマを作り直すの?</h3></div></div></div><p>
        いいえ。PHPUnit は、テストスイートの開始時にすべてのデータベースオブジェクトが存在することを前提とします。
        データベースやテーブル、シーケンス、トリガー、そしてビューなどは、
        テストスイートを実行する前に作っておく必要があります。
      </p><p>
        <a class="ulink" href="http://www.doctrine-project.org" target="_top">Doctrine 2</a> や
        <a class="ulink" href="http://www.ezcomponents.org" target="_top">eZ Components</a>
        の強力なツールを使えば、定義済みのデータ構造からデータベーススキーマを作成できます。
        しかし、これらを使うには PHPUnit extension にフックで組み込まねばなりません。
        そうしないと、テストスイートを実行する前にデータベースの自動再作成ができなくなります。
      </p><p>
        各テストの実行後はデータベースをクリアするので、
        テストを実行するたびにデータベースを再作成する必要はありません。
        事前に作ったデータベースをずっと使いまわすことができます。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="database.am-i-required-to-use-pdo-in-my-application-for-the-database-extension-to-work"></a>PDO を使ったアプリケーションじゃないと Database Extension を使えないの?</h3></div></div></div><p>
        いいえ。PDO が必要なのは、フィクスチャの準備や後始末とアサーションのときだけです。
        テスト対象のコード内では、なんでもお好みの方法でデータベースにアクセスできます。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="database.what-can-i-do-when-i-get-a-too-much-connections-error"></a><span class="quote">「<span class="quote">Too much Connections</span>」</span> というエラーが出たらどうすればいい?</h3></div></div></div><p>
        テストケースの <code class="literal">getConnection()</code> メソッドで作った
        PDO インスタンスをキャッシュしていなければ、
        データベースを使うテストを実行するたびにデータベースへの接続の数は増加し続けます。
        デフォルトの設定では MySQL が受け付ける同時接続は 100 までであり、
        他のデータベースにも同様の接続数制限があります。
      </p><p>
        <span class="quote">「<span class="quote">自前でのデータベーステストケースの抽象化</span>」</span>
        に、このエラーを回避する方法を示しています。
        ひとつの PDO インスタンスをキャッシュして、すべてのテストで使いまわす方法です。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="database.how-to-handle-null-with-flat-xml-csv-datasets"></a>フラット XML や CSV のデータセットで NULL を扱う方法は?</h3></div></div></div><p>
        そんな方法はありません。NULL が使いたければ XML あるいは YAML データセットを使わないといけません。
      </p></div></div></div>
     <div class="row">
      <div class="col-md-1 pull-left prev-nav"><a accesskey="p" href="incomplete-and-skipped-tests.html">戻る</a></div>
      <div class="col-md-1 pull-right next-nav"><a accesskey="n" href="test-doubles.html">次へ</a></div>
     </div>

   </div>
   <hr/>
   <footer>
    <p><a href="appendixes.copyright.html">Copyright</a> &copy; 2005-2017 <a href="http://sebastian-bergmann.de/">Sebastian Bergmann</a>.</p>
   </footer>
  </div>
  <script src="js/jquery.js"></script>
  <script src="js/bootstrap.min.js"></script>
  <script src="js/highlight.pack.js"></script>
  <script type="text/javascript">
  $(document).ready(function() { $('pre.programlisting').each(function(i, e) {hljs.highlightBlock(e)}); });
  </script>
 </body>
</html>
